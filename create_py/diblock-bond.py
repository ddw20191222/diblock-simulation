import math
from numpy import matrix
from numpy import array
from numpy import abs
import re
import string

import sys
sys.path.append('./')
import PDB_module

class SingleLipid:

	def __init__(self,AtomList=[],BondList=[],AngleList=[],Lbond=1.0,number1=5,number2=5,number3=0):
		if(len(AtomList) >=1 or len(BondList)>=1 or len(AngleList)>=1):
			print"---------------------------------"
			print"The initial class should be EMPTY"
			print"---------------------------------"

		self.AtomList= []
		self.BondList= []
		self.AngleList= []

		l= Lbond
		n1=number1
		n2=number2
		n3=number3
		n=n1+n2+n3
		# n1 represents the number of beads near the center,and n2 represents that far from center,n represents total beads in one direction.

		mol= []
		ang= []
		bnd= []
		ndx= 0

		#mol formate: atom index, atomtype index, atomtype, reside type, x, y, z 
		#and this list of molecular lists the information of center atom
		#mol.append([1,1,'HE','LIP',0,0,0])
		
		#r represents how many directions started from center.
		#bnd([a,b]):a,b represents the index of two atoms composed of bond.
		#The methond followed represents the moudle that the atom near center is same with center atom,if it needs to build the moudle of tetrahedra,n1=0
		#q=1 means append starts from the second molecular

	#	q=1
	#	for r in range(n):
			
		#	if (r==0):
				
			#	for k in range(n):
				#	q+=1
				#	l1=l*(k+1)
				#	if ((q-1)%(n)<(n1)):
				#		mol.append([q,1,'HE','LIP',l1,l1,l1])
				#	else:
				#		mol.append([q,2,'TA','LIP',l1,l1,l1])
					
				#	if ((q-2)%n==0 ):
				#		bnd.append([1,q])
				#	else:	
				#		bnd.append([q-1,q])
				#	if ((q-2)%n==0):
				#		ang.append([1,q,q+1])
					#elif ((q-1)%n!=0):
					#	ang.append([q-1,q,q+1])
		q=0
		for r in range(n):
			q+=1
			l1=l*(r+1)
 			#append mol  
			if (r+1<=n1):
				mol.append([q,1,'D1','LIP',l1,l1,l1])
			elif (r+1>n1 and r+1<=n2+n1):
				mol.append([q,2,'D2','LIP',l1,l1,l1])
			elif (r+1>n2+n1 and r+1<=n3+n2+n1):
				mol.append([q,1,'D3','LIP',l1,l1,l1])

			if (r+1<=n-1):
				bnd.append([q,q+1])

			#if (r+1<=n-2):
			#	ang.append([q,q+1,q+2])
            #append bnd angle
			

            
            
            

		

		#ang.append([2,1,2+n])
		#ang.append([2,1,2+2*n])
		#ang.append([2,1,2+3*n])
		#ang.append([2+n,1,2+2*n])
		#ang.append([2+n,1,2+3*n])
		#ang.append([2+2*n,1,2+3*n])

		#make the formated list for atoms,bonds,angles
		#PSF
		#Bond
		bondtype= []
		bondList= []
		bondtypetmp= []
		bondtypeindex= 0
		#p[0],p[1] corresponds to first and second element in the list of bnd[]
		#j represents the subscript generated by enumerate??????
		#Attention!the p followed is not a number,it is the sign of the list,such as "p[]".
		for j, p in enumerate(bnd):
			if (j==0):
			#different atom type of different atom
				bondtypeindex= bondtypeindex+ 1
			#The bondtypetmp can be regarded as the two element composed of bond.(It's of viatl important to add [] outside the [])
			#The bondtypetmp includes many list,composed of two numbers which represents the type of two atom composed of bond.(This list contain the type of bond,instead of the serial number of bond.)  
			#And the the two elements in bondtypetmp are the type of molecular;and "p[0]-1" represents the first atom of the bond,including the information of the first atom,"p[1]-1 represents the second atom"
			#While the list of bnd contains the serial number of bond.
			#To emphasize!Bondtypetmp represents the type of bond including the type of two atoms instead of the serial number of two atoms composed of bond. 
			#bondtypetmp:the first bond contains two numbers that represent the type of the first atom and the second atom.bond1:(atom1,atom2)
			#mol[][],first [],such as [p[0]-1] determines which list in mol.append[[],[],[]......],second [] determines the element in mol[]
			#sorted(bondtypetmp),sort the two elements in bondtypetmp[a,b] from small to big
			#for bondtypetmp,if bnd[1,2],p[0]-1=0,mol[p[0]-1][1]=mol[0][1],mol corresponds to mol after append,mol=[mol[,,,],mol[,,,],mol[,,,]],and bnd([1,2],[2,3],[3,4].....)

				bondtypetmp= [mol[p[0]-1][1],mol[p[1]-1][1]]
				bondtypetmp= sorted(bondtypetmp)
				bondtype.append([bondtypeindex,bondtypetmp[0],bondtypetmp[1]])
#for bondlist:p[]represents the serial number of the atoms composed of bond,and mol[][] represents the type of atoms composed of bond
				bondList.append([j+1,bondtypeindex,p[0],p[1],mol[p[0]-1][2],mol[p[1]-1][2]])

			#The code in the part of else prevents the type of bonds repeated,such two or more same kinds of bondtype coexist in the bondtype[] and bondList[]

			else:
#following commond makes bondtypetmp renew,generating a new bondtypetmp instead of appending a new one.
				bondtypetmp= [mol[p[0]-1][1],mol[p[1]-1][1]]
				bondtypetmp= sorted(bondtypetmp)
		
				pointer= True

#in fact :(1,2)=(2,1),for two atoms form bond
#bt corresponds the abbriviation of bondtype
#Although j==0 in if and j>0 in else,bondtype[] is appended when j==0,because they are in the same for loop. 
#And bondtypetmp changes because of the former command,bondtype does not change,then bondList is appended and then break for deleting the repetition.
			
				for b, bt in enumerate(bondtype):
#The "if" followed means the next bond includes two atoms same type with one bond in the bondtype[] 
					if([bt[1],bt[2]]== [bondtypetmp[0],bondtypetmp[1]]):
#bt[0]:bondtypeindex,bt[1]:bondtype,bt[2]:bondtype
						bondList.append([j+1,bt[0],p[0],p[1],mol[p[0]-1][2],mol[p[1]-1][2]])
						break
#len([[],[],[],[]])=4,1 dimentional[] is regarded as one element.In the followed elif,b==(len(bondtype)-1) equals to the maximum of the b
#if b=max,bondtype[max,max+1],the atom of max+1 excess the max,so an error occurs. 
#As bondtype[] appends,the maximum of b increases.The next elif illustrates when b reaches its maximum,
#I guess only the last item is different from all the items stored in the bondtype,and then the bondtypeindex needs to add 1,
#(!!only when b reaches max, bondtype could be appended,bondtypeindex could be added 1,so the length of bondtype increases,and in the next loop the time increases )
					elif(b == (len(bondtype)-1)):

						pointer = False

						bondtypeindex = bondtypeindex +1
						bondtype.append([bondtypeindex,bondtypetmp[0],bondtypetmp[1]])
						bondList.append([j+1,bondtypeindex,p[0],p[1],mol[p[0]-1][2],mol[p[1]-1][2]])
						break
#why the followed codes aren't printed in screen???
		for j,p in enumerate(bondList):
			continue
			print j,p,bnd[j]

		print "=========BOND TYPE========="
		if(len(bnd) != len(bondList)):
			print "Error in Bond Type Statistic"
			print "Num of bnd is %d" %(len(bnd))
			print "Num of bnd is %d" %(len(bondList))
			exit(1)
		#print bondtype()
		for j,p in enumerate(bondtype):
			print p[0], p[1], p[2]

		#Angle
		angletype = []
		angleList=[]
		angletypetmp=[]
		angletypetmpEnd= []
		angletypeindex= 0
		for j,p in enumerate(ang):
			if(j == 0):
				angletypeindex=angletypeindex+1
				angletypetmp= [mol[p[0]-1][1],mol[p[1]-1][1],mol[p[2]-1][1]]
				angletypetmpEnd=[angletypetmp[0],angletypetmp[2]]
				angletypetmpEnd= sorted(angletypetmpEnd)
				angletypetmp=[angletypetmpEnd[0],angletypetmp[1],angletypetmpEnd[1]]
				angletype.append([angletypeindex,angletypetmp[0],angletypetmp[1],angletypetmp[2]])
				angleList.append([j+1,angletypeindex,p[0],p[1],p[2],mol[p[0]-1][2],mol[p[1]-1][2],mol[p[2]-1][2]])
			else:
				angletypetmp=[mol[p[0]-1][1],mol[p[1]-1][1],mol[p[2]-1][1]]
				angletypetmpEnd=[angletypetmp[0],angletypetmp[2]]
				angletypetmpEnd=sorted(angletypetmpEnd)
				angletypetmp=[angletypetmpEnd[0],angletypetmp[1],angletypetmpEnd[1]]

				pointer = True

				for an,ant in enumerate(angletype):
					if([ant[1],ant[2],ant[3]]==[angletypetmp[0],angletypetmp[1],angletypetmp[2]]):
						angleList.append([j+1,ant[0],p[0],p[1],p[2],mol[p[0]-1][2],mol[p[1]-1][2],mol[p[2]-1][2]])
						break
					elif(([ant[1],ant[2],ant[3]] != [angletypetmp[0], angletypetmp[1], angletypetmp[2]]) and (an == len(angletype)-1)):

						pointer = False

						angletypeindex = angletypeindex +1
						angletype.append([angletypeindex,angletypetmp[0], angletypetmp[1], angletypetmp[2]])
						angleList.append([j+1,angletypeindex,p[0],p[1],p[2],mol[p[0]-1][2],mol[p[1]-1][2],mol[p[2]-1][2]])
						break


		print "=========ANGLE TYPE========="
		if(len(bnd) != len(bondList)):
			print "Error in Angle Type Statistic"
			print "Num of angle is %d" %(len(ang))
			print "Num of angleList is %d" %(len(angleList))

		for j,p in enumerate(angletype):
			print p[0], p[1], p[2], p[3]



#use class,correlate the PDB_module with the code now

		self.AtomList = mol
		self.BondList = bondList
		self.AngleList = angleList



		print "========================="
		print "=SYSTEM GENERATE SUCCESS="
		print "========================="

	def LIPwritePDB(self):
        #print PDB,the code next means that if the filename I set existed it's right and executes the command in try,on the opposite it's wrong and then executes the command in except.
		filename ="diblock_ab.pdb"
		try:
			fp = open(filename , 'w')
		except:
			print "Error: No such file: "+filename
			exit(1)
		for j,p in enumerate(self.AtomList):
			atom = PDB_module.Atom_class(AtomSerial=p[0], AtomName=p[2],ResidueName=p[3],ResidueSerial=1,AtomCoorX=p[4],AtomCoorY=p[5],AtomCoorZ=p[6])
			fp.write("%s\n" %(atom.atom_2_PDBformat()))
		fp.close()

		print "========================="
		print "=    PDB WRETE ENDED    ="
		print "========================="

	def LIPwritePSF(self):
    #print PSF
		filename = "diblock_ab.psf"
		try:
			fp = open(filename , 'w')
		except:
			print "Error: No such file: "+filename
			exit(1)


		fp.write("PESIDNAME LIP\n")
		fp.write("%s %3d\n" %('NUMATOM', len(self.AtomList)))
		fp.write("%s %3d\n" %('NUMBOND', len(self.BondList)))
		fp.write("%s %3d\n" %('NUMANGLE', len(self.AngleList)))
		fp.write("%s %3d\n" %('NUMIMPR', 0))

		line = ''

    #Atom part
		for j,p in enumerate(self.AtomList):
			line = PDB_module.Atom2PSF(atomHead='ATOM', atomSerial=p[0], atomName=p[1],atomType=p[2],Mass=1.0,Charge=0.0,Unset=0.0)
			fp.write("%s\n"%(line))

    #Bond part
		for j,p in enumerate(self.BondList):
			line = PDB_module.Bond2PSF(bondHead='BOND', bondSerial=p[0],bondTypeSerial=p[1],bondIndex1=p[2],bondIndex2=p[3], \
				bondIndex1Type=p[4], bondIndex2Type=p[5])
			fp.write("%s\n" %(line))

    #Angle part
		for j, p in enumerate(self.AngleList):
			line = PDB_module.Angle2PSF(angleHead='ANGLE',angleSerial=p[0],angleTypeSerial=p[1], \
				angleIndex1=p[2],angleIndex2=p[3],angleIndex3=p[4],angleIndex1Type=p[5], \
				angleIndex2Type=p[6], angleIndex3Type=p[7])
			fp.write("%s\n" %(line))

		fp.close

		print "========================="
		print "=    PSF WRIET ENDED    ="
		print "========================="

def generateSystem(bond=1.0,N1=5,N2=5,N3=0):
	lip =SingleLipid(Lbond=bond,number1=N1,number2=N2,number3=N3)
	lip.LIPwritePDB()
	lip.LIPwritePSF()

if __name__=="__main__":
	generateSystem(bond=1.0,N1=5,N2=5,N3=0)


       	   	   









